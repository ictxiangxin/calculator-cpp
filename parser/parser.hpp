/*
    Boson v1.5 - Grammar Analyzer Generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "parser.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_PARSER_HPP_
#define _BOSON_PARSER_HPP_

#include <vector>
#include <stack>
#include <set>
#include <unordered_map>
#include "token.hpp"
#include "grammar.hpp"
#include "grammar_node.hpp"

namespace boson {
    class Parser {
    public:
        Parser() = default;

        BosonGrammar parse(std::vector<Token> token_list) {
            BosonGrammar grammar;
            std::stack<int> analysis_stack;
            std::stack<BosonGrammarNode> symbol_stack;
            analysis_stack.push(0);
            int token_index = 0;
            while (token_index < token_list.size()) {
                Token &token = token_list[token_index];
                int current_state = analysis_stack.top();
                std::string operation = "e";
                if (this->_terminal_index_mapping.count(token.symbol)) {
                    int terminal_index = this->_terminal_index_mapping[token.symbol];
                    if (this->_sparse_action_table.count(current_state)) {
                        std::unordered_map<int, std::string> &actions = this->_sparse_action_table[current_state];
                        if (actions.count(terminal_index)) {
                            operation = actions[terminal_index];
                        }
                    }
                }
                char operation_flag = operation[0];
                if (operation_flag == 'e') {
                    grammar.set_error_index(token_index);
                    return grammar;
                } else if (operation_flag == 's') {
                    int state_number = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    analysis_stack.push(state_number);
                    token_index++;
                    BosonGrammarNode grammar_node(token.text);
                    symbol_stack.push(grammar_node);
                } else if (operation_flag == 'r') {
                    int statement_index = (int) strtol(operation.c_str() + 1, nullptr, 10);
                    int reduce_count = this->_reduce_symbol_count[statement_index];
                    for (int i = 0; i < reduce_count; i++) {
                        analysis_stack.pop();
                    }
                    current_state = analysis_stack.top();
                    int current_non_terminal_index_mapping = this->_reduce_non_terminal_index[statement_index];
                    int goto_next_state = -1;
                    if (this->_sparse_goto_table.count(current_state)) {
                        std::unordered_map<int, int> &goto_table = this->_sparse_goto_table[current_state];
                        if (goto_table.count(current_non_terminal_index_mapping)) {
                            goto_next_state = goto_table[current_non_terminal_index_mapping];
                        }
                    }
                    if (goto_next_state == -1) {
                        throw std::runtime_error("Invalid goto action.");
                    }
                    analysis_stack.push(goto_next_state);
                    if (this->_sentence_index_grammar_tuple_mapping.count(statement_index)) {
                        std::vector<BosonGrammarNode> symbol_package{};
                        for (int i = 0; i < reduce_count; i++) {
                            symbol_package.insert(symbol_package.begin(), symbol_stack.top());
                            symbol_stack.pop();
                        }
                        BosonGrammarNode grammar_node;
                        for (std::string &node_string : this->_sentence_index_grammar_tuple_mapping[statement_index]) {
                            if (node_string[0] == '*') {
                                int reduce_number = (int) strtol(node_string.c_str() + 1, nullptr, 10);
                                for (BosonGrammarNode &node : symbol_package[reduce_number].children()) {
                                    grammar_node.append(node);
                                }
                            } else {
                                int reduce_number = (int) strtol(node_string.c_str(), nullptr, 10);
                                grammar_node.append(symbol_package[reduce_number]);
                            }
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else if (this->_non_grammar_tuple_reduce_set.count(statement_index)) {
                        BosonGrammarNode grammar_node;
                        for (int i = 0; i < reduce_count; i++) {
                            grammar_node.insert(0, symbol_stack.top());
                            symbol_stack.pop();
                        }
                        grammar_node.set_reduce_number(statement_index);
                        symbol_stack.push(grammar_node);
                    } else {
                        throw std::runtime_error("Invalid reduce number.");
                    }
                } else if (operation_flag == 'a') {
                    grammar.set_grammar_tree(symbol_stack.top());
                    return grammar;
                } else {
                    throw std::runtime_error("Invalid action.");
                }
            }
            throw std::runtime_error("Analyzer unusual exit.");
        }

    private:
        std::unordered_map<std::string, int> _terminal_index_mapping = {
            {"!symbol_7", 0},
            {"!symbol_3", 1},
            {"!symbol_5", 2},
            {"!symbol_9", 3},
            {"$", 4},
            {"!symbol_6", 5},
            {"!symbol_1", 6},
            {"!symbol_4", 7},
            {"!symbol_8", 8},
            {"t_symbol", 9},
            {"t_number", 10},
            {"!symbol_2", 11}
        };
        std::unordered_map<int, std::unordered_map<int, std::string>> _sparse_action_table = {
            {0, {{4, "r5"}, {9, "r5"}}}, 
            {1, {{4, "a"}}}, 
            {2, {{4, "r7"}, {9, "s3"}}}, 
            {3, {{6, "s7"}, {11, "s6"}}}, 
            {4, {{4, "r19"}, {9, "r19"}}}, 
            {5, {{4, "r10"}, {9, "r10"}}}, 
            {6, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {7, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {8, {{0, "s19"}, {2, "s16"}, {3, "s15"}, {4, "r1"}, {5, "s20"}, {8, "s14"}, {9, "r1"}}}, 
            {9, {{0, "r18"}, {1, "r18"}, {2, "r18"}, {3, "r18"}, {4, "r18"}, {5, "r18"}, {7, "r18"}, {8, "r18"}, {9, "r18"}, {11, "s6"}}}, 
            {10, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {11, {{0, "r9"}, {1, "r9"}, {2, "r9"}, {3, "r9"}, {4, "r9"}, {5, "r9"}, {7, "r9"}, {8, "r9"}, {9, "r9"}}}, 
            {12, {{0, "r11"}, {1, "r11"}, {2, "r11"}, {3, "r11"}, {4, "r11"}, {5, "r11"}, {7, "r11"}, {8, "r11"}, {9, "r11"}}}, 
            {13, {{0, "s19"}, {2, "s16"}, {3, "s15"}, {5, "s20"}, {7, "s21"}, {8, "s14"}}}, 
            {14, {{9, "r13"}, {10, "r13"}, {11, "r13"}}}, 
            {15, {{9, "r16"}, {10, "r16"}, {11, "r16"}}}, 
            {16, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {17, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {18, {{9, "r6"}, {10, "r6"}, {11, "r6"}}}, 
            {19, {{9, "r12"}, {10, "r12"}, {11, "r12"}}}, 
            {20, {{9, "r20"}, {10, "r20"}, {11, "r20"}}}, 
            {21, {{0, "r3"}, {1, "r3"}, {2, "r3"}, {3, "r3"}, {4, "r3"}, {5, "r3"}, {7, "r3"}, {8, "r3"}, {9, "r3"}}}, 
            {22, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {23, {{9, "r17"}, {10, "r17"}, {11, "r17"}}}, 
            {24, {{0, "s19"}, {1, "r21"}, {2, "s16"}, {3, "s15"}, {4, "r21"}, {5, "s20"}, {7, "r21"}, {8, "s14"}, {9, "r21"}}}, 
            {25, {{0, "s19"}, {1, "r8"}, {2, "s16"}, {3, "s15"}, {4, "r8"}, {5, "s20"}, {7, "r8"}, {8, "s14"}, {9, "r8"}}}, 
            {26, {{0, "s19"}, {1, "r14"}, {2, "s16"}, {3, "s15"}, {4, "r14"}, {5, "s20"}, {7, "r14"}, {8, "s14"}, {9, "r14"}}}, 
            {27, {{0, "s19"}, {1, "r22"}, {2, "s16"}, {3, "s15"}, {5, "s20"}, {7, "r22"}, {8, "s14"}}}, 
            {28, {{1, "s29"}, {7, "s30"}}}, 
            {29, {{9, "s9"}, {10, "s12"}, {11, "s10"}}}, 
            {30, {{0, "r2"}, {1, "r2"}, {2, "r2"}, {3, "r2"}, {4, "r2"}, {5, "r2"}, {7, "r2"}, {8, "r2"}, {9, "r2"}}}, 
            {31, {{1, "r4"}, {7, "r4"}}}, 
            {32, {{0, "s19"}, {1, "r15"}, {2, "s16"}, {3, "s15"}, {5, "s20"}, {7, "r15"}, {8, "s14"}}}
        };
        std::unordered_map<int, std::unordered_map<int, int>> _sparse_goto_table = {
            {0, {{1, 1}, {11, 2}}}, 
            {2, {{4, 4}, {7, 5}}}, 
            {6, {{3, 27}, {7, 11}}}, 
            {7, {{3, 8}, {7, 11}}}, 
            {8, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {10, {{3, 13}, {7, 11}}}, 
            {13, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {16, {{3, 26}, {7, 11}}}, 
            {17, {{3, 25}, {7, 11}}}, 
            {22, {{3, 24}, {7, 11}}}, 
            {24, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {25, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {26, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {27, {{2, 28}, {5, 22}, {6, 17}, {9, 23}, {10, 18}}}, 
            {28, {{8, 31}}}, 
            {29, {{3, 32}, {7, 11}}}, 
            {32, {{5, 22}, {6, 17}, {9, 23}, {10, 18}}}
        };
        std::unordered_map<int, std::vector<std::string>> _sentence_index_grammar_tuple_mapping = {
            {11, {"0"}},
            {18, {"0"}},
            {3, {"1"}},
            {21, {"0", "*1", "2"}},
            {8, {"0", "*1", "2"}},
            {14, {"0", "1", "2"}},
            {2, {"0", "2", "*3"}},
            {15, {"1"}},
            {22, {}},
            {4, {"*0", "*1"}},
            {1, {"0", "2"}},
            {5, {}},
            {19, {"*0", "1"}}
        };
        std::vector<int> _reduce_symbol_count = {1, 3, 5, 3, 2, 0, 1, 1, 3, 1, 1, 1, 1, 1, 3, 2, 1, 1, 1, 2, 1, 3, 0};
        std::vector<int> _reduce_non_terminal_index = {0, 4, 7, 3, 2, 11, 6, 1, 3, 3, 4, 3, 10, 9, 3, 8, 9, 5, 3, 11, 10, 3, 2};
        std::set<int> _non_grammar_tuple_reduce_set = {0, 6, 7, 9, 10, 12, 13, 16, 17, 20};
    };
}

#endif
