/*
    Boson v1.5 - Grammar Analyzer Generator

        Author: ict
        Email:  ictxiangxin@hotmail.com
        Site:   https://github.com/ictxiangxin/boson

    File: "interpreter.hpp"
    These codes ware generated by the boson C++ code generator.
*/

#ifndef _BOSON_INTERPRETER_HPP_
#define _BOSON_INTERPRETER_HPP_

#include <functional>
#include <vector>
#include <set>
#include <unordered_map>
#include "semantic_node.hpp"
#include "grammar_node.hpp"

namespace boson {
    template <class T>
    class Interpreter {
    public:
        using semantic_function = std::function<BosonSemanticsNode<T>(BosonSemanticsNode<T> &)>;

        Interpreter() = default;

        BosonSemanticsNode<T> execute(BosonGrammarNode &grammar_tree) {
            return this->_semantics_analysis(grammar_tree);
        }

        void register_action(const char *reduce_name, semantic_function function) {
            std::string reduce_name_string(reduce_name);
            this->register_action(reduce_name_string, function);
        }

        void register_action(std::string &reduce_name, semantic_function function) {
            this->_semantic_action_mapping[reduce_name] = function;
        }

    private:
        std::unordered_map<int, std::string> _reduce_number_grammar_name_mapping = {
            {1, "set_variable"}, 
            {2, "function"}, 
            {14, "compute"}, 
            {8, "compute"}, 
            {21, "compute"}, 
            {18, "get_variable"}, 
            {11, "number"}
        };
        std::set<int> _naive_reduce_number_set = {3, 9, 10, 11, 12, 13, 16, 18, 20};
        std::unordered_map<std::string, semantic_function> _semantic_action_mapping{};

        BosonSemanticsNode<T> _semantics_analysis(BosonGrammarNode &grammar_tree) {
            std::string grammar_name{};
            if (this->_reduce_number_grammar_name_mapping.count(grammar_tree.get_reduce_number())) {
                grammar_name = this->_reduce_number_grammar_name_mapping[grammar_tree.get_reduce_number()];
            } else {
                grammar_name = "!grammar_hidden";
            }
            BosonSemanticsNode<T> semantic_node;
            if (grammar_tree.children().empty()) {
                semantic_node.set_reduce_number(grammar_tree.get_reduce_number());
                semantic_node.set_text(grammar_tree.get_text());
            } else {
                for (auto &grammar_node: grammar_tree.children()) {
                    semantic_node.append(this->_semantics_analysis(grammar_node));
                }
            }
            if (this->_semantic_action_mapping.count(grammar_name)) {
                return this->_semantic_action_mapping[grammar_name](semantic_node);
            } else if (this->_naive_reduce_number_set.count(grammar_tree.get_reduce_number())) {
                if (semantic_node.children().empty()) {
                    return BosonSemanticsNode<T>::null_node();
                } else if (semantic_node.children().size() == 1) {
                    return semantic_node[0];
                } else {
                    return semantic_node;
                }
            } else {
                return semantic_node;
            }
        }
    };
}

#endif
